<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Rad√≠usbr√≥√∞ir</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      text-align: center; 
      margin: 40px; 
    }
    .container {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: flex-start;
    }
    .canvas-container {
      flex: 1;
    }
    .controls-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .slider-container { 
      width: 100%;
      margin: 10px 0; 
    }
    .slider-row {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      width: 100%;
      margin: 5px 0;
    }
    .slider-label {
      width: 150px;
      text-align: right;
      margin-right: 10px;
    }
    input[type="range"] { 
      width: 200px; 
    }
    .slider-value {
      width: 40px;
      text-align: left;
      margin-left: 10px;
    }
    canvas { 
      border: 1px solid black; 
      background-color: #f0f0f0; 
    }
    button { 
      margin: 10px; 
      padding: 10px 20px; 
      font-size: 16px; 
      cursor: pointer; 
    }
    .button-group {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .mode-indicator {
      background-color: #eee;
      border-radius: 5px;
      padding: 5px 10px;
      margin: 10px;
      display: inline-block;
    }
    .active-mode {
      font-weight: bold;
      background-color: #dff0d8;
      border: 1px solid #d6e9c6;
    }
  </style>
</head>
<body>
  <h1>Rad√≠usbr√≥√∞ir</h1>

  <div class="button-group">
    <button onclick="connectSerial()">üîå Tengja Arduino</button>
    <button onclick="connectController()">üéÆ Tengja DualSense</button>
    <button id="recordBtn" onclick="startRecording()">üî¥ Hefja Uppt√∂ku</button>
    <button id="stopBtn" onclick="stopRecording()" disabled>‚èπÔ∏è St√∂√∞va Uppt√∂ku</button>
    <button id="playBtn" onclick="playBack()" disabled>‚ñ∂Ô∏è Afspilun</button>
    <button onclick="resetToOriginalPosition()">üîÑ Endurstilla</button>
  </div>

  <div>
    <span id="normalMode" class="mode-indicator active-mode">venjulegur hamur</span>
    <span id="horizontalMode" class="mode-indicator">l√°rettur hamur</span>
  </div>

  <p id="status">Sta√∞a: Tilb√∫inn</p>
  <p id="controllerStatus">St√Ωripinni: Ekki tengdur</p>
  

  <div class="container">
    <div class="canvas-container">
      <canvas id="armCanvas" width="400" height="400"></canvas>
    </div>
    
    <div class="controls-container">
      <div class="slider-container" id="sliders"></div>
<div class="slider-row">
  <div class="slider-label">
    <label for="manualShoulder">√ñxl (bein stj√≥rn)</label>
  </div>
  <input type="range" id="manualShoulder" min="0" max="180" value="97" oninput="
    document.getElementById('shoulder').value = this.value;
    document.getElementById('shoulderValue').innerText = this.value;
    updateArm();">
  <div class="slider-value">
    <span id="manualShoulderValue">97</span>¬∞
  </div>
</div>


      <div class="slider-row">
        <div class="slider-label">
          <label for="playbackSpeed">Hra√∞i</label>
        </div>
        <input type="range" id="playbackSpeed" min="1" max="10" value="5" oninput="updateSpeed()">
        <div class="slider-value">
          <span id="playbackSpeedValue">5</span>x
        </div>
      </div>
      
      <div class="slider-row">
        <div class="slider-label">
          <label for="joystickSpeed">St√Ωripinni Hra√∞i</label>
        </div>
        <input type="range" id="joystickSpeed" min="1" max="5" value="2" oninput="updateJoystickSpeed()">
        <div class="slider-value">
          <span id="joystickSpeedValue">2</span>x
        </div>
      </div>
    </div>
  </div>

  <script> // skrifta byrjar
    let port, writer;
    let recording = false;
    let playback = false;
    let movementData = []; //hreinsum hreyfig√∂gn √æegar forrit er kveikt
    let playbackIndex = 0;
    let playbackSpeed = 5; //afspilunar hra√∞i byrjar √≠ 5 (af 10)
    let joystickSpeed = 2; //hra√∞inn √° st√Ωripinna byrjar √≠ 2
    let gamepad = null;
    let gamepadConnected = false; //byrjar √≥tengdur
    let horizontalClawMode = false; //byrjar √≠ venjulegum ham
    let lastGamepadState = { //grunnstillir alla takka √° st√Ωripinna
      dpadUp: false,
      dpadDown: false,
      dpadLeft: false,
      dpadRight: false,
      circle: false,
      square: false,
      triangle: false,
      x: false,
      L1: false,
      R1: false
    };
    let controllerInterval = null;

    const joints = [ //stillir li√∞i √° arminum
      { id: "base", label: "Grunnsn√∫ningur", min: 0, max: 180, value: 98 },
      { id: "shoulder", label: "(√∂xl)", min: 0, max: 180, value: 97 },
      { id: "elbow", label: "Olnbogi", min: 0, max: 180, value: 116 },
      { id: "wristRotate", label: "Olnbogi Sn√∫ningur", min: 0, max: 180, value: 90 },
      { id: "wristBend", label: "√ölnli√∞ur Beygja", min: 0, max: 180, value: 93},
      { id: "claw", label: "Kl√≥", min: 0, max: 180, value: 64 }
    ];

    // upprunaleg sta√∞a arms, svo h√¶gt s√© a√∞ fara √≠ hana √æegar skipt er um ham
    const originalPosition = joints.map(joint => joint.value);
    
    // Upprunasta√∞a fyrir kl√≥ √æegar skipt er yfir √≠ √∞horizontal' ham
    const horizontalClawPosition = [98, 97, 116, 90, 93, 64];

    const slidersDiv = document.getElementById("sliders");
    joints.forEach(joint => {
      slidersDiv.innerHTML += `
        <div class="slider-row">
          <div class="slider-label">
            <label for="${joint.id}">${joint.label}</label>
          </div>
          <input type="range" id="${joint.id}" min="${joint.min}" max="${joint.max}" value="${joint.value}" oninput="updateArm()">
          <div class="slider-value">
            <span id="${joint.id}Value">${joint.value}</span>¬∞
          </div>
        </div>
      `;
    });
    //stillir canvas sem 2D port
    const canvas = document.getElementById("armCanvas");
    const ctx = canvas.getContext("2d");

    function updateJoystickSpeed() {
      joystickSpeed = document.getElementById("joystickSpeed").value;
      document.getElementById("joystickSpeedValue").innerText = joystickSpeed;
    }
    
    function toggleHorizontalClawMode() {
      horizontalClawMode = !horizontalClawMode;
      
      // Update mode indicators
      document.getElementById("normalMode").classList.toggle("active-mode", !horizontalClawMode);
      document.getElementById("horizontalMode").classList.toggle("active-mode", horizontalClawMode);
      
      if (horizontalClawMode) {
        // Switch to horizontal claw position
        updateSliders(horizontalClawPosition);
        sendSerialData(horizontalClawPosition);
        drawArm(horizontalClawPosition);
        if (recording) movementData.push([...horizontalClawPosition]);
      } else {
        // Return to original position
        const currentValues = joints.map(joint => parseInt(document.getElementById(joint.id).value));
        updateSliders(currentValues);
        sendSerialData(currentValues);
        drawArm(currentValues);
        if (recording) movementData.push([...currentValues]);
      }
    }
    
    // Fall sem f√¶rir arm √≠ upprunalega st√∂√∞u
    function resetToOriginalPosition() {
      if (playback) return; // kemur √≠ veg fyrir a√∞ ef √æa√∞ er afspilun √≠ gangi a√∞ √æetta keyri ekki upprunalega st√∂√∞u armsins.
      
      horizontalClawMode = false; //Byrjar √≠ venjulegum ham
      document.getElementById("normalMode").classList.add("active-mode");
      document.getElementById("horizontalMode").classList.remove("active-mode");
      
      updateSliders(originalPosition);
      sendSerialData(originalPosition);
      drawArm(originalPosition);
      if (recording) movementData.push([...originalPosition]);
      
      document.getElementById("status").innerText = "Sta√∞a: Endurstillt √≠ upphaflega st√∂√∞u";
    }

    async function connectSerial() {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        document.getElementById("status").innerText = "Sta√∞a: Tengt vi√∞ Arm";
      } catch (err) {
        console.error("Serial Connection Error:", err);
        document.getElementById("status").innerText = "Sta√∞a: Tenginging mist√≥kst";
      }
    }

    function connectController() {
      if (gamepadConnected) {
        document.getElementById("controllerStatus").innerText = "Tengt";
        return;
      }

      window.addEventListener("gamepadconnected", (e) => {
        gamepad = e.gamepad;
        gamepadConnected = true;
        document.getElementById("controllerStatus").innerText = `St√Ωripinni tengdur (${gamepad.id})`;
        
        if (controllerInterval === null) {
          controllerInterval = setInterval(updateControllerInput, 50);
        }
      });

      window.addEventListener("gamepaddisconnected", (e) => {
        gamepadConnected = false;
        document.getElementById("controllerStatus").innerText = "St√Ωripinni: aftengdurt";
        
        if (controllerInterval !== null) {
          clearInterval(controllerInterval);
          controllerInterval = null;
        }
      });
      
      document.getElementById("controllerStatus").innerText = "St√Ωripinni: bi√∞";
      navigator.getGamepads();
    }

    function updateControllerInput() {
      if (!gamepadConnected) return;
      
      // Update the gamepad state
      const gamepads = navigator.getGamepads();
      if (!gamepads[gamepad.index]) return;
      
      gamepad = gamepads[gamepad.index];
      
      // Hringur kveikir √° uppt√∂ku og slekkur √° henni.
      if (gamepad.buttons[1].pressed && !lastGamepadState.circle) {
        if (recording) {
          stopRecording();
        } else {
          startRecording();
        }
      }
      
      // Square (button 0) - Byrjar afspilun
      if (gamepad.buttons[0].pressed && !lastGamepadState.square && !recording && movementData.length > 0 && !playback) {
        playBack();
      }
      
      // Triangle (button 2) - Endurstillir arm √≠ upprunalega st√∂√∞u s√≠na
      if (gamepad.buttons[2].pressed && !lastGamepadState.triangle && !playback) {
        resetToOriginalPosition();
      }
      
      // L1 (button 4) - Toggle horizontal claw mode
      if (gamepad.buttons[4].pressed && !lastGamepadState.L1 && !playback) {
        toggleHorizontalClawMode();
      }
      
      // Skip the rest of the controls during playback
      if (playback) {
        // Uppf√¶rir st√∂√∞u hnappanna √° st√Ωripinnanum
        lastGamepadState = {
          dpadUp: gamepad.buttons[12].pressed,
          dpadDown: gamepad.buttons[13].pressed,
          dpadLeft: gamepad.buttons[14].pressed,
          dpadRight: gamepad.buttons[15].pressed,
          circle: gamepad.buttons[1].pressed,
          square: gamepad.buttons[0].pressed,
          triangle: gamepad.buttons[2].pressed,
          x: gamepad.buttons[3].pressed
        };
        return;
      }
      
      // F√¶r n√∫verandi gildi √° st√∂√∞unum √° limum
      let currentValues = joints.map(joint => parseInt(document.getElementById(joint.id).value));
      
      // Claw control with D-pad up/down (buttons 12/13)
      const dpadSpeed = gamepad.buttons[5].pressed ? 3 : 1; // √ûegar √Ωtt er √° R1 og haldi√∞ inni fer armurinn hra√∞ar, sem vi√∞ pl√∫sum svo vi√∞ hreyfinguna.
      
      if (gamepad.buttons[12].pressed) {
        // D-pad Up - open claw
        currentValues[5] = Math.min(currentValues[5] + dpadSpeed, joints[5].max);
      }
      
      if (gamepad.buttons[13].pressed) {
        // D-pad Down - close claw
        currentValues[5] = Math.max(currentValues[5] - dpadSpeed, joints[5].min);
      }
      
      // Base rotation with D-pad left/right (buttons 14/15)
      // Now moves continuously while held
      if (gamepad.buttons[14].pressed) {
        // D-pad Left - rotate base left
        currentValues[0] = Math.max(currentValues[0] - dpadSpeed, joints[0].min);
      }
      
      if (gamepad.buttons[15].pressed) {
        // D-pad Right - rotate base right
        currentValues[0] = Math.min(currentValues[0] + dpadSpeed, joints[0].max);
      }
      
      // Left joystick (axes 0,1) - control shoulder and elbow with inverse kinematics-like behavior
      // Check if R1 is pressed for speed boost
      const speedMultiplier = gamepad.buttons[5].pressed ? 3.0 : 1.0;
      const effectiveJoystickSpeed = joystickSpeed * speedMultiplier;
      
      // Get the left joystick input
      const leftJoystickX = Math.abs(gamepad.axes[0]) > 0.2 ? gamepad.axes[0] : 0;
      const leftJoystickY = Math.abs(gamepad.axes[1]) > 0.2 ? gamepad.axes[1] : 0;
      
      if (leftJoystickX !== 0 || leftJoystickY !== 0) {
        // Apply both shoulder and elbow changes based on joystick direction
        // Moving forward/back (Y-axis)
        if (leftJoystickY !== 0) {
          // Forward/backward movement changes both joints
          // Up on joystick (negative Y) raises the arm by decreasing shoulder and increasing elbow
          // Down on joystick (positive Y) lowers the arm by increasing shoulder and decreasing elbow
          currentValues[1] = Math.max(Math.min(currentValues[1] - leftJoystickY * 1.8 * effectiveJoystickSpeed, joints[1].max), joints[1].min);
          currentValues[2] = Math.max(Math.min(currentValues[2] + leftJoystickY * 1.5 * effectiveJoystickSpeed, joints[2].max), joints[2].min);
        }
        
        // Moving side to side (X-axis)
        if (leftJoystickX !== 0) {
          // Left/right movement changes both joints in opposite directions to extend/retract
          // Right on joystick (positive X) extends arm by decreasing shoulder and increasing elbow
          // Left on joystick (negative X) retracts arm by increasing shoulder and decreasing elbow
          currentValues[1] = Math.max(Math.min(currentValues[1] + leftJoystickX * 1.3 * effectiveJoystickSpeed, joints[1].max), joints[1].min);
          currentValues[2] = Math.max(Math.min(currentValues[2] + leftJoystickX * 1.8 * effectiveJoystickSpeed, joints[2].max), joints[2].min);
        }
      }
      
      // Right joystick (axes 2,3) - control wrist rotation and bend
      // Apply the same speed multiplier for R1 button
      if (Math.abs(gamepad.axes[2]) > 0.2) {
        // X-axis for wrist rotation (olnbogi sn√∫ningur)
        currentValues[3] = Math.max(Math.min(currentValues[3] + gamepad.axes[2] * 1.5 * effectiveJoystickSpeed, joints[3].max), joints[3].min);
      }
      
      if (Math.abs(gamepad.axes[3]) > 0.2) {
        // Y-axis for wrist bend (√∫lnli√∞ur beygja)
        currentValues[4] = Math.max(Math.min(currentValues[4] - gamepad.axes[3] * 1.5 * effectiveJoystickSpeed, joints[4].max), joints[4].min);
      }
      
      // In horizontal claw mode, automatically adjust the wrist to keep the claw level
      if (horizontalClawMode) {
        // Calculate how much we need to adjust the wrist to keep the claw level
        // This is based on the shoulder and elbow angles
        const shoulderDeg = parseInt(document.getElementById("shoulder").value);
        const elbowDeg = parseInt(document.getElementById("elbow").value);
        
        // Basic formula to keep the claw level - the wrist compensates for shoulder and elbow
        // We want wristBend to be such that the claw is always horizontal
        // Total angle: shoulder + elbow + wrist = 180¬∞ (when level)
        // So wrist = 360 - shoulder - elbow
        currentValues[4] = 360 - shoulderDeg - elbowDeg;
        
        // Clamp to valid range
        currentValues[4] = Math.max(Math.min(currentValues[4], joints[4].max), joints[4].min);
      }
      
      // Update lastGamepadState
      //uppf√¶rir s√≠√∞ustu st√∂√∞u √° st√Ωripinna
      lastGamepadState = {
        dpadUp: gamepad.buttons[12].pressed,
        dpadDown: gamepad.buttons[13].pressed,
        dpadLeft: gamepad.buttons[14].pressed,
        dpadRight: gamepad.buttons[15].pressed,
        circle: gamepad.buttons[1].pressed,
        square: gamepad.buttons[0].pressed,
        triangle: gamepad.buttons[2].pressed,
        x: gamepad.buttons[3].pressed,
        L1: gamepad.buttons[4].pressed,
        R1: gamepad.buttons[5].pressed
      };
      
      // Apply changes
      updateSliders(currentValues);
      sendSerialData(currentValues.map(v => Math.round(v)));
      drawArm(currentValues);
      if (recording) movementData.push([...currentValues]);
    }

    async function sendSerialData(data) {
      if (writer) {
        let encoder = new TextEncoder();
        await writer.write(encoder.encode(data.join(",") + "\n"));
      }
    }

    function startRecording() {
      recording = true;
      playback = false;
      movementData = [];
      document.getElementById("status").innerText = "Sta√∞a: Tekur upp...";
      document.getElementById("recordBtn").disabled = true;
      document.getElementById("stopBtn").disabled = false;
      document.getElementById("playBtn").disabled = true;
    }

    function stopRecording() {
      recording = false;
      document.getElementById("status").innerText = "Sta√∞a: Uppt√∂ku loki√∞";
      document.getElementById("recordBtn").disabled = false;
      document.getElementById("stopBtn").disabled = true;
      document.getElementById("playBtn").disabled = movementData.length === 0;
    }

    function updateSpeed() {
      playbackSpeed = document.getElementById("playbackSpeed").value;
      document.getElementById("playbackSpeedValue").innerText = playbackSpeed;
    }

    function playBack() {
      if (movementData.length === 0) return;
      playback = true;
      document.getElementById("status").innerText = "Sta√∞a: Spilar aftur...";
      document.getElementById("playBtn").disabled = true;
      playbackIndex = 0;
      smoothPlayback();
    }

    function smoothPlayback() {
      if (!playback || playbackIndex >= movementData.length - 1) {
        playback = false;
        document.getElementById("status").innerText = "Sta√∞a: Afspilun loki√∞";
        document.getElementById("playBtn").disabled = false;
        return;
      }

      const start = movementData[playbackIndex];
      const end = movementData[playbackIndex + 1];
      const stepCount = 10 / playbackSpeed;
      let step = 0;

      function interpolate() {
        if (step >= stepCount || !playback) {
          playbackIndex++;
          requestAnimationFrame(smoothPlayback);
          return;
        }

        const interpolated = start.map((val, i) => val + (end[i] - val) * (step / stepCount));
        updateSliders(interpolated);
        sendSerialData(interpolated.map(v => Math.round(v)));
        drawArm(interpolated);
        step++;
        requestAnimationFrame(interpolate);
      }

      interpolate();
    }

    function updateSliders(values) {
      joints.forEach((joint, i) => {
        document.getElementById(joint.id).value = values[i];
        document.getElementById(joint.id + "Value").innerText = Math.round(values[i]);
      });
    }

    function updateArm() {
      const values = joints.map(joint => parseInt(document.getElementById(joint.id).value));
      updateSliders(values);
      sendSerialData(values);
      drawArm(values);
      if (recording) movementData.push([...values]);
    }

    function drawArm(values) {
      const [base, shoulder, elbow, wristRotate, wristBend, claw] = values.map(v => parseInt(v));
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Center point and dimensions
      const centerX = canvas.width / 2;
      const baseY = 350;
      const armWidth = 15;
      
      // Segment lengths
      const baseHeight = 40;
      const shoulderLength = 100;
      const elbowLength = 80;
      const wristLength = 40; // Adding a short wrist section 
      const clawLength = 25;
      
      // Convert degrees to radians
      const rad = deg => deg * Math.PI / 180;
      
      // Base rotation (around Y axis) - correct mirroring by inverting the angle
      const baseAngle = rad(-(base - 90)); // 0-180 degrees where 90 is center, now mirrored
      
      // Draw base
      ctx.fillStyle = "#666";
      ctx.fillRect(centerX - 30, baseY - baseHeight, 60, baseHeight);
      
      // Calculate base position (top of the base)
      const baseX = centerX;
      const baseTopY = baseY - baseHeight;
      
      // Base rotation point position
      const baseJointX = baseX + Math.cos(baseAngle) * 0;
      const baseJointY = baseTopY;
      
      // Shoulder angle (0 is straight up, 180 is straight down)
      // Invert the shoulder angle (180-shoulder) to match real behavior
      const shoulderAngle = rad(180 - shoulder);
      
      // Calculate shoulder end position
      const shoulderEndX = baseJointX + Math.sin(baseAngle) * Math.sin(shoulderAngle) * shoulderLength;
      const shoulderEndY = baseJointY - Math.cos(shoulderAngle) * shoulderLength;
      const shoulderEndZ = Math.cos(baseAngle) * Math.sin(shoulderAngle) * shoulderLength;
      
      // Draw shoulder segment with perspective
      const shoulderWidth = armWidth * (1 - Math.abs(shoulderEndZ) / 200);
      
      ctx.beginPath();
      ctx.lineWidth = shoulderWidth;
      ctx.lineCap = "round";
      ctx.strokeStyle = "#3366cc";
      ctx.moveTo(baseJointX, baseJointY);
      ctx.lineTo(shoulderEndX, shoulderEndY);
      ctx.stroke();
      
      // Elbow angle (0 is straight, 180 is fully bent)
      // Invert the elbow angle (180-elbow) to match real behavior
      const elbowAngle = rad(180 - elbow);
      const totalArmAngle = shoulderAngle + elbowAngle - Math.PI; // Adjust to make 90 straight
      
      // For visualization of elbow rotation
      const elbowRotationRad = rad(wristRotate - 90); // This is olnbogi sn√∫ningur
      
      // Calculate elbow end position
      const elbowEndX = shoulderEndX + Math.sin(baseAngle) * Math.sin(totalArmAngle) * elbowLength;
      const elbowEndY = shoulderEndY - Math.cos(totalArmAngle) * elbowLength;
      const elbowEndZ = shoulderEndZ + Math.cos(baseAngle) * Math.sin(totalArmAngle) * elbowLength;
      
      // Draw elbow segment with perspective and show rotation
      const elbowWidth = armWidth * (1 - Math.abs(elbowEndZ) / 200);
      
      // Draw a circle to represent the elbow joint rotation
      ctx.beginPath();
      ctx.arc(shoulderEndX, shoulderEndY, 12, 0, Math.PI * 2);
      ctx.fillStyle = "#33aa33";
      ctx.globalAlpha = 0.3;
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw a line to indicate the elbow rotation angle
      ctx.beginPath();
      ctx.moveTo(shoulderEndX, shoulderEndY);
      ctx.lineTo(
        shoulderEndX + Math.cos(baseAngle + elbowRotationRad) * 15,
        shoulderEndY + Math.sin(elbowRotationRad) * 15
      );
      ctx.strokeStyle = "#f00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw the elbow segment
      ctx.beginPath();
      ctx.lineWidth = elbowWidth;
      ctx.strokeStyle = "#33aa33";
      ctx.moveTo(shoulderEndX, shoulderEndY);
      ctx.lineTo(elbowEndX, elbowEndY);
      ctx.stroke();
      
      // Wrist bend angle (√∫lni√∞ur beygja) - correctly orient up/down
      const wristAngle = rad(180 - wristBend);
      
      // Calculate wrist direction with correct elbow rotation and wrist bend
      const wristBaseAngle = totalArmAngle - Math.PI / 2; // Start perpendicular to arm
      
      // Apply wrist bend to get final wrist angle
      const totalWristAngle = wristBaseAngle + wristAngle;
      
      // Calculate wrist end position
      const wristEndX = elbowEndX + Math.sin(baseAngle) * Math.sin(totalWristAngle) * wristLength;
      const wristEndY = elbowEndY - Math.cos(totalWristAngle) * wristLength;
      const wristEndZ = elbowEndZ + Math.cos(baseAngle) * Math.sin(totalWristAngle) * wristLength;
      
      // Draw wrist with correct rotation
      ctx.save();
      ctx.translate(elbowEndX, elbowEndY);
      ctx.rotate(elbowRotationRad); // Rotate context based on olnbogi sn√∫ningur
      ctx.rotate(wristAngle); // Apply wrist bend
      
      // Draw wrist after rotation
      ctx.beginPath();
      ctx.lineWidth = elbowWidth - 2;
      ctx.strokeStyle = "#cc6633";
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -wristLength);
      ctx.stroke();
      
      // Draw claw with current rotation
      const clawOpening = (180 - claw) / 180 * Math.PI / 3;
      
      // Left claw
      ctx.beginPath();
      ctx.lineWidth = Math.max(2, elbowWidth - 3);
      ctx.strokeStyle = "#cc3333";
      ctx.moveTo(0, -wristLength);
      ctx.lineTo(-Math.sin(clawOpening) * clawLength, -wristLength - Math.cos(clawOpening) * clawLength);
      ctx.stroke();
      
      // Right claw
      ctx.beginPath();
      ctx.lineWidth = Math.max(2, elbowWidth - 3);
      ctx.strokeStyle = "#cc3333";
      ctx.moveTo(0, -wristLength);
      ctx.lineTo(Math.sin(clawOpening) * clawLength, -wristLength - Math.cos(clawOpening) * clawLength);
      ctx.stroke();
      
      ctx.restore();
      
      // Draw joints
      const jointPositions = [
        {x: baseJointX, y: baseJointY, size: 10, color: "#444"},
        {x: shoulderEndX, y: shoulderEndY, size: 8, color: "#3366cc"},
        {x: elbowEndX, y: elbowEndY, size: 7, color: "#33aa33"}
      ];
      
      jointPositions.forEach(joint => {
        ctx.beginPath();
        ctx.arc(joint.x, joint.y, joint.size, 0, Math.PI * 2);
        ctx.fillStyle = joint.color;
        ctx.fill();
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#000";
        ctx.stroke();
      });
      
      // Draw base rotation indicator
      ctx.beginPath();
      ctx.arc(centerX, baseY - baseHeight/2, 25, 0, Math.PI * 2);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(centerX, baseY - baseHeight/2);
      ctx.lineTo(centerX + Math.cos(baseAngle) * 25, baseY - baseHeight/2 + Math.sin(baseAngle) * 25);
      ctx.strokeStyle = "#f00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Display joint angles
      ctx.fillStyle = "#000";
      ctx.font = "12px Arial";
      ctx.textAlign = "left";
      ctx.fillText(`Base: ${base}¬∞`, 10, 20);
      ctx.fillText(`Shoulder: ${shoulder}¬∞`, 10, 40);
      ctx.fillText(`Elbow: ${elbow}¬∞`, 10, 60);
      ctx.fillText(`Olnbogi Sn√∫ningur: ${wristRotate}¬∞`, 10, 80);
      ctx.fillText(`√ölnli√∞ur Beygja: ${wristBend}¬∞`, 10, 100);
      ctx.fillText(`Claw: ${claw}¬∞`, 10, 120);
      
      // Display the current mode
      ctx.fillStyle = horizontalClawMode ? "#006400" : "#000";
      ctx.font = "12px Arial";
      ctx.textAlign = "left";
      ctx.fillText(`Mode: ${horizontalClawMode ? "Horizontal Claw (Level)" : "Normal"}`, 10, 140);
    }

    window.onload = function() {
      updateArm();
      updateJoystickSpeed();
    };
  </script>
</body>
</html>
